1. What was the problem you were solving in the projects for this course?
In these projects, I needed to build programs that could load, store, search, and validate course information using different data structures. I also had to secure a Spring Boot application by adding encryption, certificates, and dependency checks. The main goal was to understand how data structures affect performance and how secure coding practices protect real applications.

2. How did you approach the problem? Consider why data structures are important to understand.
I approached the problem by comparing how each data structure works and what it is good at. Vectors are simple but slow for searching, hash tables are fast but not ordered, and binary search trees keep data sorted but can become slow if unbalanced. Understanding these differences helped me choose the right structure for each task and write better, more efficient code.

3. How did you overcome any roadblocks you encountered while going through the activities or project?
I ran into issues like duplicate courses, missing prerequisites, and errors in the input file. I fixed these by adding validation, using helper functions, and cleaning the data. In the security project, the OWASP Dependencyâ€‘Check tool failed at first, so I updated the plugin, added my NVD API key, and disabled the analyzer causing errors. Breaking problems into smaller steps helped me solve them.

4. How has your work on this project expanded your approach to designing software and developing programs?
These projects taught me to think more about structure, performance, and security instead of just making the code run. I now plan my design more carefully, choose data structures on purpose, and think about how the program will scale. I also learned how important secure communication, encryption, and dependency management are in real software development.

5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I now write cleaner and more organized code. I focus on readability, clear naming, and breaking tasks into smaller functions. I also think more about future updates, edge cases, and how other developers will understand my work. These projects helped me build habits that make my programs easier to maintain, test, and improve over time.
